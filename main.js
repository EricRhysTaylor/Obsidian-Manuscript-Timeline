/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TimelinePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  sourcePath: "Book 1"
};
var STATUS_COLORS = {
  "Complete": "#7c6460",
  "Working": "#70b970",
  "Todo": "#aaaaaa",
  "Empty": "#eeeeee",
  "Due": "#d05e5e"
};
var NUM_ACTS = 3;
function formatNumber(num) {
  if (Math.abs(num) < 1e-3)
    return "0";
  return num.toFixed(3).replace(/\.?0+$/, "");
}
function parseSceneTitle(title) {
  const firstSpace = title.indexOf(" ");
  if (firstSpace === -1)
    return { number: "", text: title };
  const number = title.substring(0, firstSpace);
  if (!number.match(/^\d+(\.\d+)?$/)) {
    return { number: "", text: title };
  }
  return {
    number,
    text: title.substring(firstSpace + 1)
  };
}
var TimelinePlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new TimelineSettingTab(this.app, this));
    this.addCommand({
      id: "create-interactive-timeline",
      name: "Create Interactive Timeline",
      callback: async () => {
        try {
          const sceneData = await this.getSceneData();
          if (sceneData.length === 0) {
            new import_obsidian.Notice("No valid scene data found.");
            return;
          }
          await this.createTimelineHTML("Timeline", sceneData);
          new import_obsidian.Notice(`Interactive timeline created with ${sceneData.length} scenes`);
        } catch (error) {
          this.log("Error:", error);
          new import_obsidian.Notice("Failed to create timeline");
        }
      }
    });
    this.app.workspace.onLayoutReady(async () => {
      setTimeout(async () => {
        try {
          const sceneData = await this.getSceneData();
          if (sceneData.length > 0) {
            await this.createTimelineHTML("Timeline", sceneData);
            this.log("Timeline auto-generated on plugin load");
            new import_obsidian.Notice("Timeline auto-generated");
          } else {
            this.log("No scene data found for auto-generation");
            new import_obsidian.Notice("No scene data found for timeline auto-generation");
          }
        } catch (error) {
          this.log("Error auto-generating timeline:", error);
          new import_obsidian.Notice("Error auto-generating timeline");
        }
      }, 2e3);
    });
    window.addEventListener("message", async (event) => {
      if (event.data.type === "open-file") {
        const file = this.app.vault.getAbstractFileByPath(event.data.path);
        if (file instanceof import_obsidian.TFile) {
          await this.app.workspace.getLeaf().openFile(file);
        }
      }
    });
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        if (file.path.startsWith(this.settings.sourcePath) || oldPath.startsWith(this.settings.sourcePath)) {
          try {
            const sceneData = await this.getSceneData();
            if (sceneData.length > 0) {
              await this.createTimelineHTML("Timeline", sceneData);
              this.log(`Timeline updated after scene file rename: ${oldPath} -> ${file.path}`);
            }
          } catch (error) {
            this.log("Error updating timeline after rename:", error);
          }
        }
      })
    );
  }
  async getSceneData() {
    var _a;
    const files = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.sourcePath));
    const scenes = [];
    for (const file of files) {
      const metadata = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if ((metadata == null ? void 0 : metadata.Class) === "Scene" && (metadata == null ? void 0 : metadata.When)) {
        const when = new Date(metadata.When);
        if (!isNaN(when.getTime())) {
          const subplots = metadata.Subplot ? Array.isArray(metadata.Subplot) ? metadata.Subplot : [metadata.Subplot] : ["Main Plot"];
          const actNumber = metadata.Act !== void 0 ? Number(metadata.Act) : 1;
          const validActNumber = actNumber >= 1 && actNumber <= 3 ? actNumber : 1;
          let status = "Todo";
          if (metadata.Status) {
            if (Array.isArray(metadata.Status)) {
              status = metadata.Status[0];
            } else {
              status = metadata.Status;
            }
          }
          let characters = metadata.Character;
          if (characters) {
            if (!Array.isArray(characters)) {
              characters = [characters];
            }
            characters = characters.map((char) => char.replace(/[\[\]]/g, ""));
          }
          subplots.forEach((subplot) => {
            scenes.push({
              title: metadata.Title || file.basename,
              when,
              subplot,
              synopsis: metadata.Synopsis ? String(metadata.Synopsis) : "",
              actNumber: validActNumber,
              path: file.path,
              status,
              Character: characters,
              due: metadata.Due ? new Date(metadata.Due) : void 0,
              Edits: metadata.Edits || ""
            });
          });
        }
      }
    }
    return scenes.sort((a, b) => {
      const whenComparison = a.when.getTime() - b.when.getTime();
      if (whenComparison !== 0)
        return whenComparison;
      const aNumber = parseSceneTitle(a.title).number;
      const bNumber = parseSceneTitle(b.title).number;
      const aNum = aNumber ? parseFloat(aNumber) : 0;
      const bNum = bNumber ? parseFloat(bNumber) : 0;
      return aNum - bNum;
    });
  }
  createTimelineSVG(scenes) {
    const size = 1600;
    const margin = 30;
    const innerRadius = 200;
    const outerRadius = size / 2 - margin;
    const sceneNumbersMap = /* @__PURE__ */ new Map();
    const allSubplotsSet = /* @__PURE__ */ new Set();
    scenes.forEach((scene) => {
      allSubplotsSet.add(scene.subplot);
    });
    const allSubplots = Array.from(allSubplotsSet);
    const NUM_RINGS = allSubplots.length;
    const DEFAULT_RING_COLOR = "#333333";
    const scenesByActAndSubplot = {};
    for (let act = 0; act < NUM_ACTS; act++) {
      scenesByActAndSubplot[act] = {};
    }
    scenes.forEach((scene) => {
      const act = scene.actNumber - 1;
      const validAct = act >= 0 && act < NUM_ACTS ? act : 0;
      const subplot = scene.subplot || "Default";
      if (!scenesByActAndSubplot[validAct][subplot]) {
        scenesByActAndSubplot[validAct][subplot] = [];
      }
      scenesByActAndSubplot[validAct][subplot].push(scene);
    });
    const months = Array.from({ length: 12 }, (_, i) => {
      const angle = i / 12 * 2 * Math.PI - Math.PI / 2;
      const name = new Date(2e3, i).toLocaleString("en-US", { month: "long" });
      return { name, angle };
    });
    const availableSpace = outerRadius - innerRadius;
    const reductionFactor = 1;
    const N = NUM_RINGS;
    const sumOfSeries = reductionFactor === 1 ? N : (1 - Math.pow(reductionFactor, N)) / (1 - reductionFactor);
    const initialRingWidth = availableSpace / sumOfSeries;
    const ringWidths = Array.from({ length: N }, (_, i) => initialRingWidth * Math.pow(reductionFactor, i));
    const ringStartRadii = ringWidths.reduce((acc, width, i) => {
      const previousRadius = i === 0 ? innerRadius : acc[i - 1] + ringWidths[i - 1];
      acc.push(previousRadius);
      return acc;
    }, []);
    const lineInnerRadius = ringStartRadii[0] - 20;
    const lineOuterRadius = ringStartRadii[N - 1] + ringWidths[N - 1] + 30;
    let svg = `<svg width="${size}" height="${size}" viewBox="-${size / 2} -${size / 2} ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Lato:wght@400;900&display=swap');

            svg {
                font-family: 'Lato', sans-serif;
            }

            .scene-title {
                fill: white;
                opacity: 1;
              pointer-events: none;
            }

            .scene-title.faded {
                fill: black;
                opacity: 0.2;
            }

            .center-number-text {
                fill: black;
                font-size: 180px;
                pointer-events: none;
                font-weight: 900;
            }

            .scene-act {
                fill-opacity: 0;
                transition: fill-opacity 0.2s;
            }

            .scene-act:hover {
                fill-opacity: 0.3;
                cursor: pointer;
            }

            .scene-info {
                opacity: 0;
                transition: opacity 0.2s;
                pointer-events: none;
            }

            .scene-group:hover .scene-info {
                opacity: 1;
            }

            .number-text {
                font-size: 14px;
                pointer-events: none;
            }

            .number-text.faded {
                opacity: 0.2;
            }

            .number-square {
                opacity: 1;
                pointer-events: none;
            }

            .number-square.faded {
                opacity: 0.2;
            }

            .scene-path {
                opacity: 1;
                transition: opacity 0.2s ease-out;
                pointer-events: all;
            }

            .scene-path.faded {
                opacity: 0.2;
                transition: opacity 0.2s ease-out;
            }

            .scene-path.highlighted {
                opacity: 1;
                transition: opacity 0.2s ease-out;
            }

            .info-title {
                fill: #333333;
                font-size: 28px;
                text-anchor: middle;
            }

            .subplot-text {
                fill: #333333;
                font-size: 28px;
                text-anchor: middle;
            }

            .synopsis-text {
                fill: #333333;
                font-size: 28px;
                text-anchor: middle;
            }

            .month-label {
                fill: #333;
                font-size: 16px;
                pointer-events: none;
                dominant-baseline: middle;
            }

            .month-label-outer {
                fill: #333;
                font-size: 20px;
                pointer-events: none;
                dominant-baseline: middle;
            }

            .act-label {
                fill: #333;
                font-size: 20px;
                font-weight: bold;
                pointer-events: none;
                dominant-baseline: middle;
            }

            .info-container {
                fill: #333333;
                font-size: 24px;
            }

            .info-text {
                dominant-baseline: hanging;
                text-anchor: start;
            }
        </style>`;
    svg += `<defs>`;
    months.forEach(({ name, angle }, index) => {
      const outerlabelRadius = lineOuterRadius - 15;
      const pixelToRadian = 5 * 2 * Math.PI / (2 * Math.PI * outerlabelRadius);
      const startAngle2 = angle + pixelToRadian;
      const endAngle2 = angle + Math.PI / 6;
      const pathId = `monthLabelPath-${index}`;
      svg += `
                <path id="${pathId}"
                    d="
                        M ${formatNumber(outerlabelRadius * Math.cos(startAngle2))} ${formatNumber(outerlabelRadius * Math.sin(startAngle2))}
                        A ${formatNumber(outerlabelRadius)} ${formatNumber(outerlabelRadius)} 0 0 1 ${formatNumber(outerlabelRadius * Math.cos(endAngle2))} ${formatNumber(outerlabelRadius * Math.sin(endAngle2))}
                    "
                    fill="none"
                />
            `;
    });
    svg += `</defs>`;
    months.forEach(({ name }, index) => {
      const pathId = `monthLabelPath-${index}`;
      svg += `
                <text class="month-label-outer">
                    <textPath href="#${pathId}" startOffset="0" text-anchor="start">
                        ${name}
                    </textPath>
                </text>
            `;
    });
    const now = new Date();
    const startOfYear = new Date(now.getFullYear(), 0, 1);
    const yearProgress = (now.getTime() - startOfYear.getTime()) / (1e3 * 60 * 60 * 24 * 365);
    const progressRadius = lineInnerRadius + 15;
    const circumference = 2 * Math.PI * progressRadius;
    const progressLength = circumference * yearProgress;
    const startAngle = -Math.PI / 2;
    const endAngle = startAngle + 2 * Math.PI * yearProgress;
    svg += `
            <circle
                cx="0"
                cy="0"
                r="${progressRadius}"
                fill="none"
                stroke="#eeeeee"
                stroke-width="10"
            />
        `;
    svg += `
            <path
                d="
                    M ${progressRadius * Math.cos(startAngle)} ${progressRadius * Math.sin(startAngle)}
                    A ${progressRadius} ${progressRadius} 0 ${yearProgress > 0.5 ? 1 : 0} 1 
                    ${progressRadius * Math.cos(endAngle)} ${progressRadius * Math.sin(endAngle)}
                "
                fill="none"
                stroke="#9e71d0" // Purple
                stroke-width="10"
            />
        `;
    svg += `<g class="month-spokes">`;
    months.forEach(({ name, angle }, monthIndex) => {
      const x1 = formatNumber((lineInnerRadius - 5) * Math.cos(angle));
      const y1 = formatNumber((lineInnerRadius - 5) * Math.sin(angle));
      const x2 = formatNumber(lineOuterRadius * Math.cos(angle));
      const y2 = formatNumber(lineOuterRadius * Math.sin(angle));
      const isActBoundary = [0, 4, 8].includes(monthIndex);
      svg += `
                <line  
                    x1="${x1}"
                    y1="${y1}"
                    x2="${x2}"
                    y2="${y2}"
                    stroke-width="${isActBoundary ? 5 : 1}"
                    stroke="${isActBoundary ? "#AAAAAA" : "#000"}"
                />`;
      const innerLabelRadius = lineInnerRadius;
      const pixelToRadian = 5 * 2 * Math.PI / (2 * Math.PI * innerLabelRadius);
      const startAngle2 = angle + pixelToRadian;
      const endAngle2 = angle + Math.PI / 6;
      const innerPathId = `innerMonthPath-${name}`;
      svg += `
                <path id="${innerPathId}"
                    d="
                        M ${formatNumber(innerLabelRadius * Math.cos(startAngle2))} ${formatNumber(innerLabelRadius * Math.sin(startAngle2))}
                        A ${formatNumber(innerLabelRadius)} ${formatNumber(innerLabelRadius)} 0 0 1 ${formatNumber(innerLabelRadius * Math.cos(endAngle2))} ${formatNumber(innerLabelRadius * Math.sin(endAngle2))}
                    "
                    fill="none"
                />
                <text class="month-label">
                    <textPath href="#${innerPathId}" startOffset="0" text-anchor="start">
                        ${name}
                    </textPath>
                </text>
            `;
    });
    svg += `</g>`;
    const masterSubplotOrder = (() => {
      const subplotCounts = Object.entries(scenesByActAndSubplot[0]).map(([subplot, scenes2]) => ({
        subplot,
        count: scenes2.length
      }));
      subplotCounts.sort((a, b) => {
        if (a.subplot === "Main Plot" || !a.subplot)
          return -1;
        if (b.subplot === "Main Plot" || !b.subplot)
          return 1;
        return b.count - a.count;
      });
      return subplotCounts.map((item) => item.subplot);
    })();
    const synopsesHTML = [];
    scenes.forEach((scene) => {
      var _a;
      const subplotIndex = masterSubplotOrder.indexOf(scene.subplot);
      const ring = NUM_RINGS - 1 - subplotIndex;
      const scenesInActAndSubplot = scenesByActAndSubplot[scene.actNumber - 1][scene.subplot] || [];
      const sceneIndex = scenesInActAndSubplot.indexOf(scene);
      const sceneId = `scene-path-${scene.actNumber - 1}-${ring}-${sceneIndex}`;
      console.log("Looking up number info for sceneId:", sceneId);
      const numberInfo = sceneNumbersMap.get(sceneId);
      console.log("Found numberInfo:", numberInfo);
      const lineHeight2 = 30;
      const size2 = 1600;
      const maxTextWidth = 500;
      const topOffset = -size2 / 2;
      const characterColors = ((_a = scene.Character) == null ? void 0 : _a.map(
        (char) => "#" + Math.floor(Math.random() * 16777215).toString(16).padStart(6, "0")
      )) || [];
      const allSceneSubplots = scenes.filter((s) => s.path === scene.path).map((s) => s.subplot);
      const orderedSubplots = [
        scene.subplot,
        ...allSceneSubplots.filter((s) => s !== scene.subplot)
      ];
      const synopsisLines = scene.synopsis ? this.splitIntoBalancedLines(scene.synopsis, maxTextWidth) : [];
      const contentLines = [
        `${scene.title} - ${scene.when.toLocaleDateString()}`,
        ...synopsisLines,
        // Add a non-breaking space to preserve the line spacing
        "\xA0",
        // Using non-breaking space instead of empty string
        // Subplots with bullet-like separator
        orderedSubplots.map(
          (subplot, i) => `<tspan style="font-size: 17px; fill: #555555; text-transform: uppercase; font-weight: bold;">${subplot}</tspan>`
        ).join(`<tspan style="font-size: 17px; fill: #555555;"> \u2022 </tspan>`),
        // Characters with bullets between them
        scene.Character && scene.Character.length > 0 ? scene.Character.map(
          (char, i) => `<tspan style="fill: ${characterColors[i]}; font-size: 14px;">${char.toUpperCase()}</tspan>`
        ).join(`<tspan style="fill: ${characterColors[0]}; font-size: 14px;"> \u2022 </tspan>`) : ""
      ].filter((line) => line);
      const totalHeight = contentLines.length * lineHeight2;
      const showLeftText = scene.actNumber <= 2;
      const showRightText = scene.actNumber === 3;
      synopsesHTML.push(`
                <g class="scene-info info-container" 
                   style="opacity: 0; pointer-events: none;" 
                   data-for-scene="${sceneId}">
                    ${showLeftText ? `
                    <!-- Left side text block -->
                    <g transform="translate(-650, -400)">
                        ${contentLines.map((line, i) => `
                            <text class="info-text" x="10" y="${i * lineHeight2}"
                                style="${i === 0 ? "font-size: 24px; font-weight: bold;" : ""}"
                            >${line}</text>
                        `).join("")}
                    </g>
                    ` : ""}

                    <!-- Center number display -->
                    <g transform="translate(0, 0)">
                        <text 
                            x="0" 
                            y="0" 
                            text-anchor="middle" 
                            dominant-baseline="middle" 
                            class="center-number-text"
                            dy="0.1em"
                        >${parseSceneTitle(scene.title).number || "ERROR: No Number"}</text>
                    </g>

                    ${showRightText ? `
                    <!-- Right side text block -->
                    <g transform="translate(50, -400)">
                        ${contentLines.map((line, i) => `
                            <text class="info-text" x="10" y="${i * lineHeight2}"
                                style="${i === 0 ? "font-size: 24px; font-weight: bold;" : ""}"
                            >${line}</text>
                        `).join("")}
                    </g>
                    ` : ""}
                </g>
            `);
    });
    for (let act = 0; act < NUM_ACTS; act++) {
      const totalRings = NUM_RINGS;
      const subplotCount = masterSubplotOrder.length;
      const ringsToUse = Math.min(subplotCount, totalRings);
      for (let ringOffset = 0; ringOffset < ringsToUse; ringOffset++) {
        const ring = totalRings - ringOffset - 1;
        const innerR = ringStartRadii[ring];
        const outerR = innerR + ringWidths[ring];
        const startAngle2 = act * 2 * Math.PI / NUM_ACTS - Math.PI / 2;
        const endAngle2 = (act + 1) * 2 * Math.PI / NUM_ACTS - Math.PI / 2;
        const subplot = masterSubplotOrder[ringOffset];
        if (subplot) {
          const currentScenes = scenesByActAndSubplot[act][subplot] || [];
          if (currentScenes && currentScenes.length > 0) {
            const sceneAngleSize = (endAngle2 - startAngle2) / currentScenes.length;
            currentScenes.forEach((scene, idx) => {
              const { number, text } = parseSceneTitle(scene.title);
              const sceneStartAngle = startAngle2 + idx * sceneAngleSize;
              const sceneEndAngle = sceneStartAngle + sceneAngleSize;
              const textPathRadius = (innerR + outerR) / 2;
              const color = (() => {
                var _a;
                const statusList = Array.isArray(scene.status) ? scene.status : [scene.status];
                const normalizedStatus = ((_a = statusList[0]) == null ? void 0 : _a.toString().trim().toLowerCase()) || "";
                if (normalizedStatus === "complete") {
                  return STATUS_COLORS.Complete;
                }
                if (scene.due && new Date() > new Date(scene.due)) {
                  return STATUS_COLORS.Due;
                }
                return STATUS_COLORS[statusList[0]] || STATUS_COLORS.Todo;
              })();
              const arcPath = `
                                M ${formatNumber(innerR * Math.cos(sceneStartAngle))} ${formatNumber(innerR * Math.sin(sceneStartAngle))}
                                L ${formatNumber(outerR * Math.cos(sceneStartAngle))} ${formatNumber(outerR * Math.sin(sceneStartAngle))}
                                A ${formatNumber(outerR)} ${formatNumber(outerR)} 0 0 1 ${formatNumber(outerR * Math.cos(sceneEndAngle))} ${formatNumber(outerR * Math.sin(sceneEndAngle))}
                                L ${formatNumber(innerR * Math.cos(sceneEndAngle))} ${formatNumber(innerR * Math.sin(sceneEndAngle))}
                                A ${formatNumber(innerR)} ${formatNumber(innerR)} 0 0 0 ${formatNumber(innerR * Math.cos(sceneStartAngle))} ${formatNumber(innerR * Math.sin(sceneStartAngle))}
                            `;
              const sceneId = `scene-path-${act}-${ring}-${idx}`;
              const fontSize = 18;
              const dyOffset = -1;
              svg += `
                            <g class="scene-group" data-path="${encodeURIComponent(scene.path)}" id="scene-group-${act}-${ring}-${idx}">
                                <path id="${sceneId}"
                                      d="${arcPath}" 
                                      fill="${color}" 
                                      stroke="white" 
                                      stroke-width="1" 
                                      class="scene-path"/>

                                <!-- Scene title path (using only the text part) -->
                                <path id="textPath-${act}-${ring}-${idx}" 
                                      d="M ${formatNumber(textPathRadius * Math.cos(sceneStartAngle + 0.02))} ${formatNumber(textPathRadius * Math.sin(sceneStartAngle + 0.02))} 
                                         A ${formatNumber(textPathRadius)} ${formatNumber(textPathRadius)} 0 0 1 ${formatNumber(textPathRadius * Math.cos(sceneEndAngle))} ${formatNumber(textPathRadius * Math.sin(sceneEndAngle))}" 
                                      fill="none"/>
                                <text class="scene-title" style="font-size: ${fontSize}px" dy="${dyOffset}">
                                    <textPath href="#textPath-${act}-${ring}-${idx}" startOffset="4">
                                        ${text}
                                    </textPath>
                                </text>
                            </g>`;
            });
          } else {
            const dummyScenes = 4;
            for (let idx = 0; idx < dummyScenes; idx++) {
              const sceneStartAngle = startAngle2 + idx * (endAngle2 - startAngle2) / dummyScenes;
              const sceneEndAngle = startAngle2 + (idx + 1) * (endAngle2 - startAngle2) / dummyScenes;
              const arcPath = `
                                M ${formatNumber(innerR * Math.cos(sceneStartAngle))} ${formatNumber(innerR * Math.sin(sceneStartAngle))}
                                L ${formatNumber(outerR * Math.cos(sceneStartAngle))} ${formatNumber(outerR * Math.sin(sceneStartAngle))}
                                A ${formatNumber(outerR)} ${formatNumber(outerR)} 0 0 1 ${formatNumber(outerR * Math.cos(sceneEndAngle))} ${formatNumber(outerR * Math.sin(sceneEndAngle))}
                                L ${formatNumber(innerR * Math.cos(sceneEndAngle))} ${formatNumber(innerR * Math.sin(sceneEndAngle))}
                                A ${formatNumber(innerR)} ${formatNumber(innerR)} 0 0 0 ${formatNumber(innerR * Math.cos(sceneStartAngle))} ${formatNumber(innerR * Math.sin(sceneStartAngle))}
                            `;
              svg += `<path d="${arcPath}" 
                                     fill="${STATUS_COLORS.Empty}" 
                                     stroke="white" 
                                     stroke-width="1" 
                                     class="scene-path"/>`;
            }
          }
        } else {
          const arcPath = `
                        M ${formatNumber(innerR * Math.cos(startAngle2))} ${formatNumber(innerR * Math.sin(startAngle2))}
                        L ${formatNumber(outerR * Math.cos(startAngle2))} ${formatNumber(outerR * Math.sin(startAngle2))}
                        A ${formatNumber(outerR)} ${formatNumber(outerR)} 0 0 1 ${formatNumber(outerR * Math.cos(endAngle2))} ${formatNumber(outerR * Math.sin(endAngle2))}
                        L ${formatNumber(innerR * Math.cos(endAngle2))} ${formatNumber(innerR * Math.sin(endAngle2))}
                        A ${formatNumber(innerR)} ${formatNumber(innerR)} 0 0 0 ${formatNumber(innerR * Math.cos(startAngle2))} ${formatNumber(innerR * Math.sin(startAngle2))}
                    `;
          const defaultEmptyColor = "#f0f0f0";
          svg += `<path d="${arcPath}" fill="${defaultEmptyColor}" stroke="white" stroke-width="1"/>`;
        }
      }
    }
    for (let act = 0; act < NUM_ACTS; act++) {
      const angle = act * 2 * Math.PI / NUM_ACTS - Math.PI / 2;
      svg += `<line 
                x1="${formatNumber(innerRadius * Math.cos(angle))}" 
                y1="${formatNumber(innerRadius * Math.sin(angle))}"
                x2="${formatNumber(outerRadius * Math.cos(angle))}" 
                y2="${formatNumber(outerRadius * Math.sin(angle))}"
                stroke="#AAAAAA"
                stroke-width="5"
                fill="none"
            />`;
    }
    const actualOuterRadius = ringStartRadii[NUM_RINGS - 1] + ringWidths[NUM_RINGS - 1];
    for (let act = 0; act < NUM_ACTS; act++) {
      const angle = act * 2 * Math.PI / NUM_ACTS - Math.PI / 2;
      const actLabelRadius = actualOuterRadius + 14;
      const angleOffset = -0.08;
      const startAngle2 = angle + angleOffset;
      const endAngle2 = startAngle2 + Math.PI / 12;
      const actPathId = `actPath-${act}`;
      svg += `
                <path id="${actPathId}"
                    d="
                        M ${formatNumber(actLabelRadius * Math.cos(startAngle2))} ${formatNumber(actLabelRadius * Math.sin(startAngle2))}
                        A ${formatNumber(actLabelRadius)} ${formatNumber(actLabelRadius)} 0 0 1 ${formatNumber(actLabelRadius * Math.cos(endAngle2))} ${formatNumber(actLabelRadius * Math.sin(endAngle2))}
                    "
                    fill="none"
                />
                <text class="act-label">
                    <textPath href="#${actPathId}" startOffset="0" text-anchor="start">
                        ACT ${act + 1}
                    </textPath>
                </text>
            `;
    }
    const keyX = size / 2 - 200;
    const keyY = -size / 2 + 50;
    const swatchSize = 20;
    const textOffset = 30;
    const lineHeight = 30;
    const processedScenes = /* @__PURE__ */ new Set();
    const statusCounts = scenes.reduce((acc, scene) => {
      var _a;
      if (processedScenes.has(scene.path)) {
        return acc;
      }
      processedScenes.add(scene.path);
      const normalizedStatus = ((_a = scene.status) == null ? void 0 : _a.toString().trim().toLowerCase()) || "";
      if (normalizedStatus === "complete") {
        acc["Complete"] = (acc["Complete"] || 0) + 1;
      } else if (scene.due && new Date() > new Date(scene.due)) {
        acc["Due"] = (acc["Due"] || 0) + 1;
      } else {
        acc[scene.status] = (acc[scene.status] || 0) + 1;
      }
      return acc;
    }, {});
    svg += `
            <g class="color-key">
                <!-- Status swatches and labels -->
                ${Object.entries(STATUS_COLORS).filter(([status]) => status !== "Empty").map(([status, color], index) => `
                        <g transform="translate(${keyX}, ${keyY + index * lineHeight})">
                            <!-- Color swatch -->
                            <rect 
                                x="0" 
                                y="0" 
                                width="${swatchSize}" 
                                height="${swatchSize}" 
                                fill="${color}"
                            />
                            
                            <!-- Status label and count -->
                            <text 
                                x="${textOffset}" 
                                y="${swatchSize / 2}" 
                                alignment-baseline="middle" 
                                class="key-text"
                                style="font-size: 16px; fill: #333333;"
                            >${status} (${statusCounts[status] || 0})</text>
                        </g>
                    `).join("")}
            </g>
        `;
    svg += `<g class="number-squares">`;
    scenes.forEach((scene) => {
      const { number } = parseSceneTitle(scene.title);
      if (number) {
        console.log("Processing scene title:", scene.title);
        console.log("Extracted number:", number);
        const subplotIndex = masterSubplotOrder.indexOf(scene.subplot);
        const ring = NUM_RINGS - 1 - subplotIndex;
        const scenesInActAndSubplot = scenesByActAndSubplot[scene.actNumber - 1][scene.subplot] || [];
        const sceneIndex = scenesInActAndSubplot.indexOf(scene);
        const act = scene.actNumber - 1;
        const startAngle2 = act * 2 * Math.PI / NUM_ACTS - Math.PI / 2;
        const endAngle2 = (act + 1) * 2 * Math.PI / NUM_ACTS - Math.PI / 2;
        const sceneAngleSize = (endAngle2 - startAngle2) / scenesInActAndSubplot.length;
        const sceneStartAngle = startAngle2 + sceneIndex * sceneAngleSize;
        const textPathRadius = (ringStartRadii[ring] + (ringStartRadii[ring] + ringWidths[ring])) / 2;
        const getSquareSize = (num) => {
          const height = 18;
          if (num.includes(".")) {
            return {
              width: num.length <= 3 ? 24 : num.length <= 4 ? 32 : 36,
              height
            };
          } else {
            return {
              width: num.length === 1 ? 20 : num.length === 2 ? 24 : 28,
              height
            };
          }
        };
        const squareSize = getSquareSize(number);
        const squareX = textPathRadius * Math.cos(sceneStartAngle) + 2;
        const squareY = textPathRadius * Math.sin(sceneStartAngle) + 2;
        const sceneId = `scene-path-${act}-${ring}-${sceneIndex}`;
        console.log("Storing number info for sceneId:", sceneId);
        sceneNumbersMap.set(sceneId, {
          number,
          x: squareX,
          y: squareY,
          width: squareSize.width,
          height: squareSize.height
        });
        const hasEdits = scene.Edits && scene.Edits.trim() !== "";
        const squareBackgroundColor = hasEdits ? "#9e71d0" : "white";
        const textColor = hasEdits ? "white" : "black";
        svg += `
                    <g transform="translate(${squareX}, ${squareY})">
                        <rect 
                            x="-${squareSize.width / 2}" 
                            y="-${squareSize.height / 2}" 
                            width="${squareSize.width}" 
                            height="${squareSize.height}" 
                            fill="${squareBackgroundColor}" 
                            class="number-square"
                            data-scene-id="${sceneId}"
                        />
                        <text 
                            x="0" 
                            y="0" 
                            text-anchor="middle" 
                            dominant-baseline="middle" 
                            class="number-text"
                            data-scene-id="${sceneId}"
                            dy="0.1em"
                            fill="${textColor}"
                        >${number}</text>
                    </g>
                `;
      }
    });
    svg += `</g>`;
    console.log("Scene Numbers Map:", sceneNumbersMap);
    svg += `
            <g class="synopses-container">
                ${synopsesHTML.join("\n")}
            </g>
        `;
    const scriptSection = `
        <script>
            document.querySelectorAll('.scene-group').forEach(sceneGroup => {
                const scenePath = sceneGroup.querySelector('.scene-path');
                const sceneId = scenePath.id;
                const synopsis = document.querySelector(\`.scene-info[data-for-scene="\${sceneId}"]\`);
                
                sceneGroup.addEventListener('mouseenter', () => {
                    if (synopsis) {
                        synopsis.style.opacity = '1';
                        synopsis.style.pointerEvents = 'all';
                    }
                });
                
                sceneGroup.addEventListener('mouseleave', () => {
                    if (synopsis) {
                        synopsis.style.opacity = '0';
                        synopsis.style.pointerEvents = 'none';
                    }
                });
            });
        <\/script>`;
    svg += `
            ${scriptSection}
        </svg>`;
    return svg;
  }
  darkenColor(color, percent) {
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.max((num >> 16) - amt, 0);
    const G = Math.max((num >> 8 & 255) - amt, 0);
    const B = Math.max((num & 255) - amt, 0);
    return `#${(1 << 24 | R << 16 | G << 8 | B).toString(16).slice(1)}`;
  }
  /// Helper function to split text into balanced lines
  splitIntoBalancedLines(text, maxWidth) {
    const words = text.split(" ");
    const lines = [];
    let currentLine = [];
    let currentLength = 0;
    const targetCharsPerLine = 60;
    for (let word of words) {
      const wordLength = word.length + 1;
      if (currentLength + wordLength > targetCharsPerLine) {
        if (currentLine.length > 0) {
          lines.push(currentLine.join(" "));
          currentLine = [word];
          currentLength = wordLength;
        } else {
          currentLine.push(word);
          lines.push(currentLine.join(" "));
          currentLine = [];
          currentLength = 0;
        }
      } else {
        currentLine.push(word);
        currentLength += wordLength;
      }
    }
    if (currentLine.length > 0) {
      lines.push(currentLine.join(" "));
    }
    return lines;
  }
  // Add a helper method for hyphenation
  hyphenateWord(word, maxWidth, charWidth) {
    const maxChars = Math.floor(maxWidth / charWidth);
    if (word.length <= maxChars)
      return [word, ""];
    const firstPart = word.slice(0, maxChars - 1) + "-";
    const secondPart = word.slice(maxChars - 1);
    return [firstPart, secondPart];
  }
  formatSynopsis(text, innerRadius, fontSize) {
    const maxTextWidth = innerRadius * 2;
    const maxWordsPerLine = 7;
    const lines = this.splitIntoBalancedLines(text, maxWordsPerLine);
    const characterWidth = 0.6 * fontSize;
    return lines.map((line, i) => {
      const spaceCount = line.split(" ").length - 1;
      const lineWidth = line.length * characterWidth;
      const extraSpace = maxTextWidth - lineWidth;
      if (lineWidth < maxTextWidth && lines.length > 1 && spaceCount > 0 && extraSpace > 0) {
        const spacesNeeded = extraSpace / spaceCount;
        line = line.split(" ").join(" ".repeat(Math.ceil(spacesNeeded)));
        if (spacesNeeded < 0) {
          this.log(`Negative spacesNeeded for line: "${line}"`);
        }
      }
      return `<text class="synopsis-text" x="0" y="${20 + i * 25}" text-anchor="middle">${line}</text>`;
    }).join(" ");
  }
  formatSubplot(subplots) {
    const subplotsList = subplots.split(",").map((subplot) => subplot.trim());
    return subplotsList.map((subplot, i) => {
      return `<text class="subplot-text" x="0" y="${-20 + i * 25}" text-anchor="middle">${subplot}</text>`;
    }).join(" ");
  }
  async createTimelineHTML(title, scenes) {
    try {
      const folderPath = "Outline";
      if (!await this.app.vault.adapter.exists(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      const htmlPath = `${folderPath}/${title}.html`;
      const html = `<!DOCTYPE html>
    <html>
    <head>
        <title>Interactive Timeline</title>
        <style>
            html, body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                overflow: auto;
                font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, sans-serif;
                background-color: #F8F5F2;
            }
            body { display: grid; place-items: center; }
            #timeline-container {
                width: 100%;
                height: 100%;
                display: grid;
                place-items: center;
                background-color: #F8F5F2;
            }
            .month-label {
                fill: #333;
                font-size: 16px;
                pointer-events: none;
                dominant-baseline: middle;
            }
            .act-label {
                fill: #333;
                font-size: 16px;
                pointer-events: none;
                dominant-baseline: middle;
            }
            svg {
                max-width: 100%;
                max-height: 100%;
                width: 100vw;
                height: 100vh;
                object-fit: contain;
            }
    
            /* New CSS classes for faded and highlighted states */
            .scene-path.faded {
                opacity: 0.5;
                transition: opacity 0.2s ease-out;
            }
    
            .scene-path.highlighted {
                opacity: 1;
                transition: opacity 0.2s ease-out;
            }
        </style>
    </head>
    <body>
        <div id="timeline-container">
            ${this.createTimelineSVG(scenes)}
        </div>
        <script>
            // JavaScript to handle hover and click effects
            const sceneGroups = document.querySelectorAll('.scene-group');
            const EMPTY_COLOR = "${STATUS_COLORS.Empty}"; // Get the Empty status color
            
            sceneGroups.forEach(scene => {
                scene.addEventListener('click', async (e) => {
                    e.preventDefault();
                    const path = decodeURIComponent(scene.getAttribute('data-path'));
                    console.log('Click: Opening file:', path);
                    
                    try {
                        const file = window.parent.app.vault.getAbstractFileByPath(path);
                        if (file) {
                            console.log('File found, opening:', file.path);
                            await window.parent.app.workspace.getLeaf().openFile(file);
                            console.log('File opened successfully');
                        } else {
                            console.log('File not found:', path);
                        }
                    } catch (error) {
                        console.log('Error opening file:', error);
                    }
                });

                scene.addEventListener('mouseenter', (e) => {
                    // Add reveal functionality
                    const path = decodeURIComponent(scene.getAttribute('data-path'));
                    if (window.parent.app) {
                        const fileExplorer = window.parent.app.workspace.getLeavesOfType('file-explorer')[0];
                        if (fileExplorer) {
                            try {
                                const file = window.parent.app.vault.getAbstractFileByPath(path);
                                if (file) {
                                    fileExplorer.view.revealInFolder(file);
                                }
                            } catch (e) {
                                console.log('Error revealing file:', e);
                            }
                        }
                    }

                    const scenePathId = scene.querySelector('.scene-path').id;
                    
                    // Store original colors and change others to Empty color
                    sceneGroups.forEach(s => {
                        const path = s.querySelector('.scene-path');
                        if (path.id !== scenePathId) {
                            // Store the original color if not already stored
                            if (!path.getAttribute('data-original-color')) {
                                path.setAttribute('data-original-color', path.getAttribute('fill'));
                            }
                            path.setAttribute('fill', EMPTY_COLOR);
                        }
                        
                        const title = s.querySelector('.scene-title');
                        if (title && path.id !== scenePathId) {
                            title.classList.add('faded');
                        }
                    });

                    // Fade all number squares and text except for the current scene
                    document.querySelectorAll('.number-square, .number-text').forEach(element => {
                        if (element.getAttribute('data-scene-id') !== scenePathId) {
                            element.classList.add('faded');
                            // For squares with purple background, change to white with black text when faded
                            if (element.classList.contains('number-square')) {
                                element.setAttribute('data-original-fill', element.getAttribute('fill'));
                                element.setAttribute('fill', 'white');
                            }
                            if (element.classList.contains('number-text')) {
                                element.setAttribute('data-original-fill', element.getAttribute('fill'));
                                element.setAttribute('fill', 'black');
                            }
                        }
                    });
                });

                scene.addEventListener('mouseleave', () => {
                    // Restore original colors
                    sceneGroups.forEach(s => {
                        const path = s.querySelector('.scene-path');
                        const originalColor = path.getAttribute('data-original-color');
                        if (originalColor) {
                            path.setAttribute('fill', originalColor);
                            path.removeAttribute('data-original-color');
                        }
                        
                        const title = s.querySelector('.scene-title');
                        if (title) title.classList.remove('faded');
                    });

                    // Remove fading and restore original colors for all number squares and text
                    document.querySelectorAll('.number-square, .number-text').forEach(element => {
                        element.classList.remove('faded');
                        const originalFill = element.getAttribute('data-original-fill');
                        if (originalFill) {
                            element.setAttribute('fill', originalFill);
                            element.removeAttribute('data-original-fill');
                        }
                    });
                });
            });
        <\/script>
    </body>
    </html>`;
      await this.app.vault.adapter.write(htmlPath, html);
    } catch (error) {
      this.log("Error creating timeline:", error);
      throw error;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Add this helper function at the class level
  parseSceneTitle(title) {
    const parts = title.trim().split(/\s+(.+)/);
    if (parts.length > 1 && !isNaN(parseFloat(parts[0]))) {
      return {
        number: parts[0],
        cleanTitle: parts[1]
      };
    }
    return {
      number: "",
      cleanTitle: title.trim()
    };
  }
  log(message, data) {
    const console2 = window.console;
    if (console2) {
      if (data) {
        console2.log(`Timeline Plugin: ${message}`, data);
      } else {
        console2.log(`Timeline Plugin: ${message}`);
      }
    }
  }
};
var TimelineSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Source Path").setDesc("Path to folder containing scene files").addText((text) => text.setPlaceholder("Enter path").setValue(this.plugin.settings.sourcePath).onChange(async (value) => {
      this.plugin.settings.sourcePath = value;
      await this.plugin.saveSettings();
    }));
  }
};
